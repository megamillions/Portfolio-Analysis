#! python3
# basketPriceRecommendations.py - Suggest the amount of a stock to buy or sell,
# based on preset units within a basket.

import numpy as np
import os
import pandas as pd
import time
import yfinance as yf

file_path = '.\\Reference\\%s'
file_name = 'stocks.csv'

sleep = 0.26

ira_approx_value = 78
inv_approx_value = 26
ira_pctg = ira_approx_value / (ira_approx_value + inv_approx_value)

# Move from thousands back to single dollars.
factor = 1000
ira_approx_value *= factor
inv_approx_value *= factor

# Divide by sample * 10, divided again by weekdays.
unit = ((ira_approx_value + inv_approx_value) / 300) / 5

df = pd.read_csv(os.path.abspath(file_path %
                                 file_name)).sort_values(by = 'TICKER')

# Select only relevant columns.
df = df[['TICKER', 'INVEST_BUY', 'IRA_BUY', 'INVEST_SELL', 'IRA_SELL']].copy()

# Exclude any with null values.
df = df[~df[['INVEST_BUY', 'IRA_BUY',
             'INVEST_SELL', 'IRA_SELL']].isna().all(axis = 1)].copy()

# Mark manually those counting as a full basket, and others counting as half.
ira_sell_baskets = df['IRA_SELL'].count()
inv_sell_baskets = df['INVEST_SELL'].count()

# Align buy and sell units more or less to the amount generated by sells.
ira_buy_unit = unit * 1.0625    # Keep at 1x to close open option positions.
inv_buy_unit = unit * 0.5515

# Sell units at half the nominal unit rate.
ira_sell_unit = unit * 0.5
inv_sell_unit = ira_sell_unit * 0.5

def print_recommendations(df, recommendation, account,
                          account_action, shares_recommendation):
    
    print('\n%s the following for the %s account:\n' % (recommendation,
                                                        account))
    
    for n in range(len(df)):
        row = df.loc[n, :]
        
        if not np.isnan(row[account_action]):
            print('%s:' % (row['TICKER']),
                  '{:.3f}'.format(row[shares_recommendation]), 'shares at',
                  '${:.2f}.'.format(row['PRICE']))

    return

def recommend_amount(row):

    # Be respectful to the server.
    time.sleep(sleep)    

    try:
        
        print('Getting the prices and amounts for %s.' % row['TICKER'])

        # Get the closing price.
        price = yf.Ticker(row['TICKER']).history().iloc[-1]['Close']
        
        inv_buy_share = shares_amount(inv_buy_unit, row['INVEST_BUY'], price)
        ira_buy_share = shares_amount(ira_buy_unit, row['IRA_BUY'], price)
        
        inv_sell_share = shares_amount(inv_sell_unit, row['INVEST_SELL'],
                                          price)
        ira_sell_share = shares_amount(ira_sell_unit, row['IRA_SELL'],
                                       price)
            
        return {'TICKER' : row['TICKER'],
                'PRICE' : price,
                'INVEST_BUY_SHARES' : inv_buy_share,
                'IRA_BUY_SHARES' : ira_buy_share,
                'INVEST_SELL_SHARES' : inv_sell_share,
                'IRA_SELL_SHARES' : ira_sell_share}
    
    except IndexError as e:
        print('Error encountered on %s: %s' % (row['TICKER'], e))
        
        return {'TICKER' : row['TICKER'],
                'PRICE' : np.nan,
                'INVEST_BUY_SHARES' : np.nan,
                'IRA_BUY_SHARES' : np.nan,
                'INVEST_SELL_SHARES' : np.nan,
                'IRA_SELL_SHARES' : np.nan}

# Returns the amount of shares to buy or sell.
def shares_amount(units, basket_size, price):
    return units / basket_size / price if basket_size is not np.nan\
        else basket_size

df = pd.merge(df, pd.DataFrame(list(df.apply(recommend_amount, axis = 1))),
              on = 'TICKER')

print_recommendations(df, 'BUY', 'INVESTMENT',
                      'INVEST_BUY', 'INVEST_BUY_SHARES')

print_recommendations(df, 'BUY', 'IRA',
                      'IRA_BUY', 'IRA_BUY_SHARES')

print_recommendations(df, 'SELL', 'INVESTMENT',
                      'INVEST_SELL', 'INVEST_SELL_SHARES')

print_recommendations(df, 'SELL', 'IRA',
                      'IRA_SELL', 'IRA_SELL_SHARES')

print('\nUnit: ${:,.2f}\n'.format(unit))
